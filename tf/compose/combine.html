<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>tf.compose.combine API documentation</title>
<meta name="description" content="Combine â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.compose.combine</code></h1>
</header>
<section id="section-intro">
<h1 id="combine">Combine</h1>
<h2 id="usage">Usage</h2>
<pre><code class="language-python">from tf.compose import combine
combine(
  (
      location1,
      location2,
  ),
  targetLocation,
)
</code></pre>
<pre><code>combine(
  (
      (name1, location1),
      (name2, location2),
  ),
  targetLocation,
  componentType=None,
  componentFeature=None,
  featureMeta=None,
  **otext,
)
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/cc16a67323f4c9ddd7056d8290920c2b46793c3c/tf/compose/combine.py#L0-L541" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# Combine

## Usage

```python
from tf.compose import combine
combine(
  (
      location1,
      location2,
  ),
  targetLocation,
)
```

```
combine(
  (
      (name1, location1),
      (name2, location2),
  ),
  targetLocation,
  componentType=None,
  componentFeature=None,
  featureMeta=None,
  **otext,
)
```
&#34;&#34;&#34;

import os
import collections

from ..fabric import Fabric
from ..core.data import WARP
from ..core.timestamp import Timestamp
from ..core.helpers import dirEmpty

OTYPE = WARP[0]
OSLOTS = WARP[1]
OTEXT = WARP[2]

GENERATED = set(
    &#34;&#34;&#34;
    writtenBy
    dateWritten
    version
&#34;&#34;&#34;.strip().split()
)

TM = Timestamp()
indent = TM.indent
info = TM.info
warning = TM.warning
error = TM.error
setSilent = TM.setSilent
isSilent = TM.isSilent


def combine(
    locations,
    targetLocation,
    componentType=None,
    componentFeature=None,
    mergeTypes=None,
    featureMeta=None,
    silent=False,
):
    &#34;&#34;&#34;Creates a new TF data source out of a number of other ones.

    You may pass as many component data sources as you want.

    The combination will be the union of all nodes of the components,
    rearranged according to their types, where node types with the
    same names will be merged.

    The slots of the result are the concatenation of the slots of the
    components, which must all have the same slot type.

    The node and edge features will be remapped, so that they have
    the same values in the combined data as they had in the individual
    components.

    Optionally, nodes corresponding to the components themselves will be
    added to the combined result.

    Care will be taken of the metadata of the features and the contents
    of the `otext.tf` feature, which consists of metadata only.

    All details of the combination can be steered by means of parameters.

    Parameters
    ----------

    locations: tuple of (string or tuple)
        You can either pass just the locations of the components,
        or you can give them a name and pass `(name, location)` instead.
        If you do not give a name to a component, its location will be used as name.

    targetLocation: string
        The directory into which the feature files of the combined dataset
        will be written.

    componentType, componentFeature: string, optional `None`
        If a string value for one of these is passed, a new node type will be added,
        with nodes for each component.
        There will also be a new feature, that assigns the name of a component
        to the node of that component.

        The name of the new node type is the value of `componentType`
        if it is a non-empty string, else it is the value of `componentFeature`.

        The name of the new feature is `componentFeature`
        if it is a non-empty string, else it is the value of `componentType`.

        !!! caution &#34;componentType must be fresh&#34;
            It is an error if the `componentType` is a node type that already
            occurs in one of the components.

        !!! note &#34;componentFeature may exist&#34;
            The `componentFeature` may already exist in one or more components.
            In that case the new feature values for nodes of `componentType` will
            just be added to it.

        Example
        -------
            combine(
                (&#39;banks&#39;, &#39;banks/tf/0.2&#39;),
                (&#39;river&#39;, &#39;banks/tf/0.4&#39;),
                &#39;riverbanks/tf/1.0&#39;,
                componentType=&#39;volume&#39;,
                componentFeature=&#39;vol&#39;,
            )

        This results of a dataset with nodes and features from the components
        found at the indicated places on your file system.
        After combination, the components are visible in the data set as nodes
        of type `volume`, and the feature `vol` provides the names `banks` and `river`
        for those nodes.

    featureMeta: dict, optional `None`
        The meta data of the components involved will be merged.
        If feature metadata of the same feature is encountered in different components,
        and if components specify different values for the same keys,
        the different values will be stored under a key with the name of
        the component appended to the key, separated by a `!`.

        The special metadata field `valueType` will just be reduced to one single value `str`
        if some components have it as `str` and others as `int`.
        If the components assign the same value type to a feature, that value type
        will be assigned to the combined feature.

        If you want to assign other meta data to specific features,
        or pass meta data for new features that orginate from the merging process,
        you can pass them in the parameter `featureMeta` as in the following example,
        where we pass meta data for a feature called `level` with integer values.

        The contents of the `otext.tf` features are also metadata,
        and their contents will be merged in exactly the same way.

        So if the section/structure specifications and the formats are not
        the same for all components, you will see them spread out
        in fields qualified by the component name with a `!` sign between
        the key and the component.

        But you can add new specifications explicitly,
        as meta data of the `otext` feature.
        by passing them as keyword arguments.
        They will be passed directly to the combined `otext.tf` feature
        and will override anything with the same key
        that is already in one of the components.

    silent: boolean, optional `False`
        Suppress or enable informational messages.

    Example
    -------
        combine(
            (&#39;banks&#39;, &#39;banks/tf/0.2&#39;),
            (&#39;river&#39;, &#39;banks/tf/0.4&#39;),
            &#39;riverbanks/tf/1.0&#39;,
            featureMeta=dict(
              level=dict(
                valueType=&#39;int&#39;,
                description=&#39;level of a section node&#39;,
              ),
            ),
        )

    Example
    -------
        combine(
            (&#39;banks&#39;, &#39;banks/tf/0.2&#39;),
            (&#39;river&#39;, &#39;banks/tf/0.4&#39;),
            &#39;riverbanks/tf/1.0&#39;,
            featureMeta=dict(
                otext=dict(
                    componentType=&#39;volume&#39;,
                    componentFeature=&#39;vol&#39;,
                    sectionTypes=&#39;volume,chapter,line&#39;,
                    sectionFeatures=&#39;title,number,number&#39;,
                ),
            ),
            silent=False,
        )

    This will give rise to something like this (assuming that `banks` and
    `rivers` have some deviating material in their `otext.tf`:

        @config
        @compiler=Dirk Roorda
        @dateWritten=2019-05-20T19:12:23Z
        @fmt:line-default={letters:XXX}{terminator}
        @fmt:line-term=line#{terminator}
        @fmt:text-orig-extra={letters}{punc}{gap}
        @fmt:text-orig-full={letters}
        @fmt:text-orig-full!banks={letters}{punc}
        @fmt:text-orig-full!rivers={letters}{gap}
        @name=Culture quotes from Iain Banks
        @purpose=exposition
        @sectionFeatures=title,number,number
        @sectionFeatures!banks=title,number,number
        @sectionFeatures!rivers=number,number,number
        @sectionTypes=volume,chapter,line
        @sectionTypes!banks=book,chapter,sentence
        @sectionTypes!rivers=chapter,sentence,line
        @source=Good Reads
        @status=with for similarities in a separate module
        @structureFeatures!banks=title,number,number,number
        @structureFeatures!rivers=title,number,number
        @structureTypes!banks=book,chapter,sentence,line
        @structureTypes!rivers=book,chapter,sentence
        @url=https://www.goodreads.com/work/quotes/14366-consider-phlebas
        @version=0.2
        @writtenBy=Text-Fabric
        @writtenBy=Text-Fabric
        @dateWritten=2019-05-28T10:55:06Z

    &#34;&#34;&#34;

    if not dirEmpty(targetLocation):
        error(
            &#34;Output directory is not empty.&#34;
            &#34; Clean it or remove it or choose another location&#34;,
            tm=False,
        )
        return False

    locations = sorted(locations)
    nodeTypesComp = collections.defaultdict(dict)
    slotTypes = collections.defaultdict(dict)
    slotType = None
    offsets = collections.defaultdict(dict)
    nodeTypes = {}
    nodeFeatures = {}
    edgeFeatures = {}
    componentOslots = {}
    componentOtype = {}
    componentValue = collections.defaultdict(dict)
    metaData = collections.defaultdict(dict)
    if componentType:
        if not componentFeature:
            componentFeature = componentType
    else:
        if componentFeature:
            componentType = componentFeature

    srcs = {0: componentType}
    locs = {0: targetLocation}
    for (i, loc) in enumerate(locations):
        if type(loc) is str:
            locs[i + 1] = loc
            srcs[i + 1] = loc
        else:
            (name, loc) = loc
            locs[i + 1] = loc
            srcs[i + 1] = name
    locItems = sorted(x for x in locs.items() if x[0])

    def getMetas():
        meta = collections.defaultdict(
            lambda: collections.defaultdict(lambda: collections.defaultdict(set))
        )

        for (feat, keys) in featureMeta.items():
            for (key, value) in keys.items():
                if value is not None:
                    meta[feat][key][value] = {0}

        if componentFeature:
            meta[componentFeature][&#34;valueType&#34;][&#34;str&#34;] = {0}
            meta[componentFeature][&#34;description&#34;][f&#34;label of {componentType}&#34;] = {0}

        for (i, loc) in locItems:
            TF = Fabric(locations=loc, silent=silent)
            for (feat, fObj) in TF.features.items():
                if fObj.method:
                    continue
                fObj.load(metaOnly=True, silent=silent or True)
                thisMeta = fObj.metaData
                for (k, v) in thisMeta.items():
                    meta[feat][k][v].add(i)

        for (feat, ks) in meta.items():
            for (k, vs) in ks.items():
                isGenerated = k in GENERATED
                if k == &#34;valueType&#34;:
                    if len(vs) &gt; 1:
                        warning(
                            f&#34;WARNING: {feat}: valueType varies in components; will be str&#34;,
                            tm=False,
                        )
                    else:
                        metaData[feat][k] = sorted(vs)[0]
                elif len(vs) == 1 and not isGenerated:
                    metaData[feat][k] = sorted(vs)[0]
                else:
                    hasCombinedValue = False
                    for (v, iis) in vs.items():
                        for i in iis:
                            if i == 0 and not isGenerated:
                                hasCombinedValue = True
                                key = k
                            else:
                                key = f&#34;{k}!{srcs[i]}&#34;
                            metaData[feat][key] = v
                    if not hasCombinedValue and not isGenerated:
                        warning(
                            f&#34;WARNING: {feat}.{k} metadata varies across sources&#34;,
                            tm=False,
                        )

        return True

    def getNtypes():
        nonlocal slotType
        nonlocal slotTypes

        clashes = set()

        good = True
        indent(level=1, reset=True)
        maxSlot = 0
        maxNode = 0

        for (i, loc) in locItems:
            info(f&#34;\r{i:&gt;3} {os.path.basename(loc)})&#34;, nl=False)
            TF = Fabric(locations=loc, silent=silent)
            api = TF.load(&#34;&#34;, silent=silent)
            if not api:
                good = False
                continue
            C = api.C
            nTypeInfo = C.levels.data
            for (t, (nType, av, nF, nT)) in enumerate(nTypeInfo):
                if nType == componentType:
                    clashes.add(i)
                if t == len(nTypeInfo) - 1:
                    slotTypes[nType][i] = (1, nT)
                    maxSlot = nT
                    maxNode = nT
                else:
                    nodeTypesComp[nType][i] = (nF, nT)
                    if nT &gt; maxNode:
                        maxNode = nT
            if componentType:
                nodeTypesComp[componentType][i] = (maxNode + 1, maxNode + 1)
                componentOslots[i] = maxSlot
                componentOtype[i] = maxNode + 1
                componentValue[i][maxNode + 1] = srcs[i]
        if len(slotTypes) &gt; 1:
            slotRep = &#34;, &#34;.join(sorted(slotTypes))
            error(f&#34;Multiple slot types: {slotRep}&#34;, tm=False)
            good = False
        commonTypes = set(slotTypes) &amp; set(nodeTypesComp)
        if len(commonTypes):
            error(
                &#34;Some node types are slots in one source and non slots in another&#34;,
                tm=False,
            )
            error(&#34;, &#34;.sorted(commonTypes), tm=False)
            good = False
        if clashes:
            clashRep = &#34;, &#34;.join(f&#34;{srcs[i]}&#34; for i in clashes)
            error(
                f&#34;Component type {componentType} occurs inside components {clashRep}&#34;,
                tm=False,
            )
            good = False
        if good:
            slotType = list(slotTypes)[0]
            nodeTypesComp[slotType] = slotTypes[slotType]
            slotTypes = set(slotTypes[slotType])
        info(&#34;\r&#34;, tm=False, nl=False)
        info(&#34;done&#34;)
        return good

    def getOffsets():
        curOffset = 0
        for i in sorted(slotTypes):
            offsets[slotType][i] = curOffset
            curOffset += nodeTypesComp[slotType][i][1]
        nodeTypes[slotType] = (1, curOffset)

        for (nType, boundaries) in sorted(nodeTypesComp.items()):
            if nType == slotType:
                continue
            for (i, (nF, nT)) in boundaries.items():
                offsets[nType][i] = curOffset - nF + 1
                curOffset += nT - nF + 1

        for (nType, offs) in offsets.items():
            boundaries = nodeTypesComp[nType]
            nF = min(offs[i] + boundaries[i][0] for i in boundaries)
            nT = max(offs[i] + boundaries[i][1] for i in boundaries)
            nodeTypes[nType] = (nF, nT)
        return True

    def remapFeatures():
        indent(level=1, reset=True)
        for (i, loc) in locItems:
            info(f&#34;\r{i:&gt;3} {os.path.basename(loc)})&#34;, nl=False)
            TF = Fabric(locations=loc, silent=silent)
            api = TF.loadAll(silent=silent)
            if not api:
                return False

            F = api.F
            Fs = api.Fs
            Es = api.Es
            fOtype = F.otype.v

            # node features

            for feat in api.Fall():
                fObj = Fs(feat)
                isOtype = feat == OTYPE
                data = {}
                for (nType, boundaries) in nodeTypesComp.items():
                    if i not in boundaries:
                        continue
                    (nF, nT) = boundaries[i]
                    cType = None
                    if nType == componentType and isOtype:
                        cType = componentType
                    thisOffset = offsets[nType][i]
                    for n in range(nF, nT + 1):
                        val = fObj.v(n) if cType is None else cType
                        if val is not None:
                            data[thisOffset + n] = val
                nodeFeatures.setdefault(feat, {}).update(data)

            if componentFeature:
                data = {}
                boundaries = nodeTypesComp[componentType]
                if i in boundaries:
                    (nF, nT) = boundaries[i]
                    thisOffset = offsets[componentType][i]
                    for n in range(nF, nT + 1):
                        val = componentValue[i][n]
                        if val is not None:
                            data[thisOffset + n] = val
                    nodeFeatures.setdefault(componentFeature, {}).update(data)

            # edge features

            for feat in api.Eall():
                eObj = Es(feat)
                isOslots = feat == OSLOTS
                edgeValues = False if isOslots else eObj.edgeValues
                data = {}
                for (nType, boundaries) in nodeTypesComp.items():
                    if i not in boundaries:
                        continue
                    cSlots = None
                    if nType == slotType and isOslots:
                        continue
                    if nType == componentType and isOslots:
                        cSlots = set(range(1, componentOslots[i] + 1))
                    (nF, nT) = boundaries[i]
                    thisOffset = offsets[nType][i]
                    for n in range(nF, nT + 1):
                        values = (
                            (eObj.s(n) if cSlots is None else cSlots)
                            if isOslots
                            else eObj.f(n)
                        )
                        nOff = thisOffset + n
                        if edgeValues:
                            newVal = {}
                            for (m, v) in values:
                                mType = fOtype(m)
                                thatOffset = offsets[mType][i]
                                newVal[thatOffset + m] = v
                        else:
                            newVal = set()
                            for m in values:
                                mType = fOtype(m)
                                thatOffset = offsets[mType][i]
                                newVal.add(thatOffset + m)
                        data[nOff] = newVal

                edgeFeatures.setdefault(feat, {}).update(data)

        return True

    def writeTf():
        TF = Fabric(locations=targetLocation, silent=True)
        TF.save(
            metaData=metaData,
            nodeFeatures=nodeFeatures,
            edgeFeatures=edgeFeatures,
            silent=silent or True,
        )
        return True

    def process():
        indent(level=0, reset=True)
        info(&#34;inspect metadata ...&#34;)
        if not getMetas():
            return False
        info(&#34;determine nodetypes ...&#34;)
        if not getNtypes():
            return False
        info(&#34;compute offsets ...&#34;)
        if not getOffsets():
            return False
        info(&#34;remap features ...&#34;)
        if not remapFeatures():
            return False
        info(&#34;write TF data ...&#34;)
        if not writeTf():
            return False
        info(&#34;done&#34;)
        return True

    wasSilent = isSilent()
    setSilent(silent)
    result = process()
    setSilent(wasSilent)
    return result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.compose.combine.combine"><code class="name flex">
<span>def <span class="ident">combine</span></span>(<span>locations, targetLocation, componentType=None, componentFeature=None, mergeTypes=None, featureMeta=None, silent=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new TF data source out of a number of other ones.</p>
<p>You may pass as many component data sources as you want.</p>
<p>The combination will be the union of all nodes of the components,
rearranged according to their types, where node types with the
same names will be merged.</p>
<p>The slots of the result are the concatenation of the slots of the
components, which must all have the same slot type.</p>
<p>The node and edge features will be remapped, so that they have
the same values in the combined data as they had in the individual
components.</p>
<p>Optionally, nodes corresponding to the components themselves will be
added to the combined result.</p>
<p>Care will be taken of the metadata of the features and the contents
of the <code>otext.tf</code> feature, which consists of metadata only.</p>
<p>All details of the combination can be steered by means of parameters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>locations</code></strong> :&ensp;<code>tuple</code> of <code>(string</code> or <code>tuple)</code></dt>
<dd>You can either pass just the locations of the components,
or you can give them a name and pass <code>(name, location)</code> instead.
If you do not give a name to a component, its location will be used as name.</dd>
<dt><strong><code>targetLocation</code></strong> :&ensp;<code>string</code></dt>
<dd>The directory into which the feature files of the combined dataset
will be written.</dd>
<dt><strong><code>componentType</code></strong>, <strong><code>componentFeature</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>
<p>If a string value for one of these is passed, a new node type will be added,
with nodes for each component.
There will also be a new feature, that assigns the name of a component
to the node of that component.</p>
<p>The name of the new node type is the value of <code>componentType</code>
if it is a non-empty string, else it is the value of <code>componentFeature</code>.</p>
<p>The name of the new feature is <code>componentFeature</code>
if it is a non-empty string, else it is the value of <code>componentType</code>.</p>
<div class="admonition caution">
<p class="admonition-title">componentType must be fresh</p>
<p>It is an error if the <code>componentType</code> is a node type that already
occurs in one of the components.</p>
</div>
<div class="admonition note">
<p class="admonition-title">componentFeature may exist</p>
<p>The <code>componentFeature</code> may already exist in one or more components.
In that case the new feature values for nodes of <code>componentType</code> will
just be added to it.</p>
</div>
<h2 id="example">Example</h2>
<pre><code>combine(
    ('banks', 'banks/tf/0.2'),
    ('river', 'banks/tf/0.4'),
    'riverbanks/tf/1.0',
    componentType='volume',
    componentFeature='vol',
)
</code></pre>
<p>This results of a dataset with nodes and features from the components
found at the indicated places on your file system.
After combination, the components are visible in the data set as nodes
of type <code>volume</code>, and the feature <code>vol</code> provides the names <code>banks</code> and <code>river</code>
for those nodes.</p>
</dd>
<dt><strong><code>featureMeta</code></strong> :&ensp;<code>dict</code>, optional <code>None</code></dt>
<dd>
<p>The meta data of the components involved will be merged.
If feature metadata of the same feature is encountered in different components,
and if components specify different values for the same keys,
the different values will be stored under a key with the name of
the component appended to the key, separated by a <code>!</code>.</p>
<p>The special metadata field <code>valueType</code> will just be reduced to one single value <code>str</code>
if some components have it as <code>str</code> and others as <code>int</code>.
If the components assign the same value type to a feature, that value type
will be assigned to the combined feature.</p>
<p>If you want to assign other meta data to specific features,
or pass meta data for new features that orginate from the merging process,
you can pass them in the parameter <code>featureMeta</code> as in the following example,
where we pass meta data for a feature called <code>level</code> with integer values.</p>
<p>The contents of the <code>otext.tf</code> features are also metadata,
and their contents will be merged in exactly the same way.</p>
<p>So if the section/structure specifications and the formats are not
the same for all components, you will see them spread out
in fields qualified by the component name with a <code>!</code> sign between
the key and the component.</p>
<p>But you can add new specifications explicitly,
as meta data of the <code>otext</code> feature.
by passing them as keyword arguments.
They will be passed directly to the combined <code>otext.tf</code> feature
and will override anything with the same key
that is already in one of the components.</p>
</dd>
<dt><strong><code>silent</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Suppress or enable informational messages.</dd>
</dl>
<h2 id="example_1">Example</h2>
<pre><code>combine(
    ('banks', 'banks/tf/0.2'),
    ('river', 'banks/tf/0.4'),
    'riverbanks/tf/1.0',
    featureMeta=dict(
      level=dict(
        valueType='int',
        description='level of a section node',
      ),
    ),
)
</code></pre>
<h2 id="example_2">Example</h2>
<pre><code>combine(
    ('banks', 'banks/tf/0.2'),
    ('river', 'banks/tf/0.4'),
    'riverbanks/tf/1.0',
    featureMeta=dict(
        otext=dict(
            componentType='volume',
            componentFeature='vol',
            sectionTypes='volume,chapter,line',
            sectionFeatures='title,number,number',
        ),
    ),
    silent=False,
)
</code></pre>
<p>This will give rise to something like this (assuming that <code>banks</code> and
<code>rivers</code> have some deviating material in their <code>otext.tf</code>:</p>
<pre><code>@config
@compiler=Dirk Roorda
@dateWritten=2019-05-20T19:12:23Z
@fmt:line-default={letters:XXX}{terminator}
@fmt:line-term=line#{terminator}
@fmt:text-orig-extra={letters}{punc}{gap}
@fmt:text-orig-full={letters}
@fmt:text-orig-full!banks={letters}{punc}
@fmt:text-orig-full!rivers={letters}{gap}
@name=Culture quotes from Iain Banks
@purpose=exposition
@sectionFeatures=title,number,number
@sectionFeatures!banks=title,number,number
@sectionFeatures!rivers=number,number,number
@sectionTypes=volume,chapter,line
@sectionTypes!banks=book,chapter,sentence
@sectionTypes!rivers=chapter,sentence,line
@source=Good Reads
@status=with for similarities in a separate module
@structureFeatures!banks=title,number,number,number
@structureFeatures!rivers=title,number,number
@structureTypes!banks=book,chapter,sentence,line
@structureTypes!rivers=book,chapter,sentence
@url=&lt;https://www.goodreads.com/work/quotes/14366-consider-phlebas&gt;
@version=0.2
@writtenBy=Text-Fabric
@writtenBy=Text-Fabric
@dateWritten=2019-05-28T10:55:06Z
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/cc16a67323f4c9ddd7056d8290920c2b46793c3c/tf/compose/combine.py#L61-L542" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def combine(
    locations,
    targetLocation,
    componentType=None,
    componentFeature=None,
    mergeTypes=None,
    featureMeta=None,
    silent=False,
):
    &#34;&#34;&#34;Creates a new TF data source out of a number of other ones.

    You may pass as many component data sources as you want.

    The combination will be the union of all nodes of the components,
    rearranged according to their types, where node types with the
    same names will be merged.

    The slots of the result are the concatenation of the slots of the
    components, which must all have the same slot type.

    The node and edge features will be remapped, so that they have
    the same values in the combined data as they had in the individual
    components.

    Optionally, nodes corresponding to the components themselves will be
    added to the combined result.

    Care will be taken of the metadata of the features and the contents
    of the `otext.tf` feature, which consists of metadata only.

    All details of the combination can be steered by means of parameters.

    Parameters
    ----------

    locations: tuple of (string or tuple)
        You can either pass just the locations of the components,
        or you can give them a name and pass `(name, location)` instead.
        If you do not give a name to a component, its location will be used as name.

    targetLocation: string
        The directory into which the feature files of the combined dataset
        will be written.

    componentType, componentFeature: string, optional `None`
        If a string value for one of these is passed, a new node type will be added,
        with nodes for each component.
        There will also be a new feature, that assigns the name of a component
        to the node of that component.

        The name of the new node type is the value of `componentType`
        if it is a non-empty string, else it is the value of `componentFeature`.

        The name of the new feature is `componentFeature`
        if it is a non-empty string, else it is the value of `componentType`.

        !!! caution &#34;componentType must be fresh&#34;
            It is an error if the `componentType` is a node type that already
            occurs in one of the components.

        !!! note &#34;componentFeature may exist&#34;
            The `componentFeature` may already exist in one or more components.
            In that case the new feature values for nodes of `componentType` will
            just be added to it.

        Example
        -------
            combine(
                (&#39;banks&#39;, &#39;banks/tf/0.2&#39;),
                (&#39;river&#39;, &#39;banks/tf/0.4&#39;),
                &#39;riverbanks/tf/1.0&#39;,
                componentType=&#39;volume&#39;,
                componentFeature=&#39;vol&#39;,
            )

        This results of a dataset with nodes and features from the components
        found at the indicated places on your file system.
        After combination, the components are visible in the data set as nodes
        of type `volume`, and the feature `vol` provides the names `banks` and `river`
        for those nodes.

    featureMeta: dict, optional `None`
        The meta data of the components involved will be merged.
        If feature metadata of the same feature is encountered in different components,
        and if components specify different values for the same keys,
        the different values will be stored under a key with the name of
        the component appended to the key, separated by a `!`.

        The special metadata field `valueType` will just be reduced to one single value `str`
        if some components have it as `str` and others as `int`.
        If the components assign the same value type to a feature, that value type
        will be assigned to the combined feature.

        If you want to assign other meta data to specific features,
        or pass meta data for new features that orginate from the merging process,
        you can pass them in the parameter `featureMeta` as in the following example,
        where we pass meta data for a feature called `level` with integer values.

        The contents of the `otext.tf` features are also metadata,
        and their contents will be merged in exactly the same way.

        So if the section/structure specifications and the formats are not
        the same for all components, you will see them spread out
        in fields qualified by the component name with a `!` sign between
        the key and the component.

        But you can add new specifications explicitly,
        as meta data of the `otext` feature.
        by passing them as keyword arguments.
        They will be passed directly to the combined `otext.tf` feature
        and will override anything with the same key
        that is already in one of the components.

    silent: boolean, optional `False`
        Suppress or enable informational messages.

    Example
    -------
        combine(
            (&#39;banks&#39;, &#39;banks/tf/0.2&#39;),
            (&#39;river&#39;, &#39;banks/tf/0.4&#39;),
            &#39;riverbanks/tf/1.0&#39;,
            featureMeta=dict(
              level=dict(
                valueType=&#39;int&#39;,
                description=&#39;level of a section node&#39;,
              ),
            ),
        )

    Example
    -------
        combine(
            (&#39;banks&#39;, &#39;banks/tf/0.2&#39;),
            (&#39;river&#39;, &#39;banks/tf/0.4&#39;),
            &#39;riverbanks/tf/1.0&#39;,
            featureMeta=dict(
                otext=dict(
                    componentType=&#39;volume&#39;,
                    componentFeature=&#39;vol&#39;,
                    sectionTypes=&#39;volume,chapter,line&#39;,
                    sectionFeatures=&#39;title,number,number&#39;,
                ),
            ),
            silent=False,
        )

    This will give rise to something like this (assuming that `banks` and
    `rivers` have some deviating material in their `otext.tf`:

        @config
        @compiler=Dirk Roorda
        @dateWritten=2019-05-20T19:12:23Z
        @fmt:line-default={letters:XXX}{terminator}
        @fmt:line-term=line#{terminator}
        @fmt:text-orig-extra={letters}{punc}{gap}
        @fmt:text-orig-full={letters}
        @fmt:text-orig-full!banks={letters}{punc}
        @fmt:text-orig-full!rivers={letters}{gap}
        @name=Culture quotes from Iain Banks
        @purpose=exposition
        @sectionFeatures=title,number,number
        @sectionFeatures!banks=title,number,number
        @sectionFeatures!rivers=number,number,number
        @sectionTypes=volume,chapter,line
        @sectionTypes!banks=book,chapter,sentence
        @sectionTypes!rivers=chapter,sentence,line
        @source=Good Reads
        @status=with for similarities in a separate module
        @structureFeatures!banks=title,number,number,number
        @structureFeatures!rivers=title,number,number
        @structureTypes!banks=book,chapter,sentence,line
        @structureTypes!rivers=book,chapter,sentence
        @url=https://www.goodreads.com/work/quotes/14366-consider-phlebas
        @version=0.2
        @writtenBy=Text-Fabric
        @writtenBy=Text-Fabric
        @dateWritten=2019-05-28T10:55:06Z

    &#34;&#34;&#34;

    if not dirEmpty(targetLocation):
        error(
            &#34;Output directory is not empty.&#34;
            &#34; Clean it or remove it or choose another location&#34;,
            tm=False,
        )
        return False

    locations = sorted(locations)
    nodeTypesComp = collections.defaultdict(dict)
    slotTypes = collections.defaultdict(dict)
    slotType = None
    offsets = collections.defaultdict(dict)
    nodeTypes = {}
    nodeFeatures = {}
    edgeFeatures = {}
    componentOslots = {}
    componentOtype = {}
    componentValue = collections.defaultdict(dict)
    metaData = collections.defaultdict(dict)
    if componentType:
        if not componentFeature:
            componentFeature = componentType
    else:
        if componentFeature:
            componentType = componentFeature

    srcs = {0: componentType}
    locs = {0: targetLocation}
    for (i, loc) in enumerate(locations):
        if type(loc) is str:
            locs[i + 1] = loc
            srcs[i + 1] = loc
        else:
            (name, loc) = loc
            locs[i + 1] = loc
            srcs[i + 1] = name
    locItems = sorted(x for x in locs.items() if x[0])

    def getMetas():
        meta = collections.defaultdict(
            lambda: collections.defaultdict(lambda: collections.defaultdict(set))
        )

        for (feat, keys) in featureMeta.items():
            for (key, value) in keys.items():
                if value is not None:
                    meta[feat][key][value] = {0}

        if componentFeature:
            meta[componentFeature][&#34;valueType&#34;][&#34;str&#34;] = {0}
            meta[componentFeature][&#34;description&#34;][f&#34;label of {componentType}&#34;] = {0}

        for (i, loc) in locItems:
            TF = Fabric(locations=loc, silent=silent)
            for (feat, fObj) in TF.features.items():
                if fObj.method:
                    continue
                fObj.load(metaOnly=True, silent=silent or True)
                thisMeta = fObj.metaData
                for (k, v) in thisMeta.items():
                    meta[feat][k][v].add(i)

        for (feat, ks) in meta.items():
            for (k, vs) in ks.items():
                isGenerated = k in GENERATED
                if k == &#34;valueType&#34;:
                    if len(vs) &gt; 1:
                        warning(
                            f&#34;WARNING: {feat}: valueType varies in components; will be str&#34;,
                            tm=False,
                        )
                    else:
                        metaData[feat][k] = sorted(vs)[0]
                elif len(vs) == 1 and not isGenerated:
                    metaData[feat][k] = sorted(vs)[0]
                else:
                    hasCombinedValue = False
                    for (v, iis) in vs.items():
                        for i in iis:
                            if i == 0 and not isGenerated:
                                hasCombinedValue = True
                                key = k
                            else:
                                key = f&#34;{k}!{srcs[i]}&#34;
                            metaData[feat][key] = v
                    if not hasCombinedValue and not isGenerated:
                        warning(
                            f&#34;WARNING: {feat}.{k} metadata varies across sources&#34;,
                            tm=False,
                        )

        return True

    def getNtypes():
        nonlocal slotType
        nonlocal slotTypes

        clashes = set()

        good = True
        indent(level=1, reset=True)
        maxSlot = 0
        maxNode = 0

        for (i, loc) in locItems:
            info(f&#34;\r{i:&gt;3} {os.path.basename(loc)})&#34;, nl=False)
            TF = Fabric(locations=loc, silent=silent)
            api = TF.load(&#34;&#34;, silent=silent)
            if not api:
                good = False
                continue
            C = api.C
            nTypeInfo = C.levels.data
            for (t, (nType, av, nF, nT)) in enumerate(nTypeInfo):
                if nType == componentType:
                    clashes.add(i)
                if t == len(nTypeInfo) - 1:
                    slotTypes[nType][i] = (1, nT)
                    maxSlot = nT
                    maxNode = nT
                else:
                    nodeTypesComp[nType][i] = (nF, nT)
                    if nT &gt; maxNode:
                        maxNode = nT
            if componentType:
                nodeTypesComp[componentType][i] = (maxNode + 1, maxNode + 1)
                componentOslots[i] = maxSlot
                componentOtype[i] = maxNode + 1
                componentValue[i][maxNode + 1] = srcs[i]
        if len(slotTypes) &gt; 1:
            slotRep = &#34;, &#34;.join(sorted(slotTypes))
            error(f&#34;Multiple slot types: {slotRep}&#34;, tm=False)
            good = False
        commonTypes = set(slotTypes) &amp; set(nodeTypesComp)
        if len(commonTypes):
            error(
                &#34;Some node types are slots in one source and non slots in another&#34;,
                tm=False,
            )
            error(&#34;, &#34;.sorted(commonTypes), tm=False)
            good = False
        if clashes:
            clashRep = &#34;, &#34;.join(f&#34;{srcs[i]}&#34; for i in clashes)
            error(
                f&#34;Component type {componentType} occurs inside components {clashRep}&#34;,
                tm=False,
            )
            good = False
        if good:
            slotType = list(slotTypes)[0]
            nodeTypesComp[slotType] = slotTypes[slotType]
            slotTypes = set(slotTypes[slotType])
        info(&#34;\r&#34;, tm=False, nl=False)
        info(&#34;done&#34;)
        return good

    def getOffsets():
        curOffset = 0
        for i in sorted(slotTypes):
            offsets[slotType][i] = curOffset
            curOffset += nodeTypesComp[slotType][i][1]
        nodeTypes[slotType] = (1, curOffset)

        for (nType, boundaries) in sorted(nodeTypesComp.items()):
            if nType == slotType:
                continue
            for (i, (nF, nT)) in boundaries.items():
                offsets[nType][i] = curOffset - nF + 1
                curOffset += nT - nF + 1

        for (nType, offs) in offsets.items():
            boundaries = nodeTypesComp[nType]
            nF = min(offs[i] + boundaries[i][0] for i in boundaries)
            nT = max(offs[i] + boundaries[i][1] for i in boundaries)
            nodeTypes[nType] = (nF, nT)
        return True

    def remapFeatures():
        indent(level=1, reset=True)
        for (i, loc) in locItems:
            info(f&#34;\r{i:&gt;3} {os.path.basename(loc)})&#34;, nl=False)
            TF = Fabric(locations=loc, silent=silent)
            api = TF.loadAll(silent=silent)
            if not api:
                return False

            F = api.F
            Fs = api.Fs
            Es = api.Es
            fOtype = F.otype.v

            # node features

            for feat in api.Fall():
                fObj = Fs(feat)
                isOtype = feat == OTYPE
                data = {}
                for (nType, boundaries) in nodeTypesComp.items():
                    if i not in boundaries:
                        continue
                    (nF, nT) = boundaries[i]
                    cType = None
                    if nType == componentType and isOtype:
                        cType = componentType
                    thisOffset = offsets[nType][i]
                    for n in range(nF, nT + 1):
                        val = fObj.v(n) if cType is None else cType
                        if val is not None:
                            data[thisOffset + n] = val
                nodeFeatures.setdefault(feat, {}).update(data)

            if componentFeature:
                data = {}
                boundaries = nodeTypesComp[componentType]
                if i in boundaries:
                    (nF, nT) = boundaries[i]
                    thisOffset = offsets[componentType][i]
                    for n in range(nF, nT + 1):
                        val = componentValue[i][n]
                        if val is not None:
                            data[thisOffset + n] = val
                    nodeFeatures.setdefault(componentFeature, {}).update(data)

            # edge features

            for feat in api.Eall():
                eObj = Es(feat)
                isOslots = feat == OSLOTS
                edgeValues = False if isOslots else eObj.edgeValues
                data = {}
                for (nType, boundaries) in nodeTypesComp.items():
                    if i not in boundaries:
                        continue
                    cSlots = None
                    if nType == slotType and isOslots:
                        continue
                    if nType == componentType and isOslots:
                        cSlots = set(range(1, componentOslots[i] + 1))
                    (nF, nT) = boundaries[i]
                    thisOffset = offsets[nType][i]
                    for n in range(nF, nT + 1):
                        values = (
                            (eObj.s(n) if cSlots is None else cSlots)
                            if isOslots
                            else eObj.f(n)
                        )
                        nOff = thisOffset + n
                        if edgeValues:
                            newVal = {}
                            for (m, v) in values:
                                mType = fOtype(m)
                                thatOffset = offsets[mType][i]
                                newVal[thatOffset + m] = v
                        else:
                            newVal = set()
                            for m in values:
                                mType = fOtype(m)
                                thatOffset = offsets[mType][i]
                                newVal.add(thatOffset + m)
                        data[nOff] = newVal

                edgeFeatures.setdefault(feat, {}).update(data)

        return True

    def writeTf():
        TF = Fabric(locations=targetLocation, silent=True)
        TF.save(
            metaData=metaData,
            nodeFeatures=nodeFeatures,
            edgeFeatures=edgeFeatures,
            silent=silent or True,
        )
        return True

    def process():
        indent(level=0, reset=True)
        info(&#34;inspect metadata ...&#34;)
        if not getMetas():
            return False
        info(&#34;determine nodetypes ...&#34;)
        if not getNtypes():
            return False
        info(&#34;compute offsets ...&#34;)
        if not getOffsets():
            return False
        info(&#34;remap features ...&#34;)
        if not remapFeatures():
            return False
        info(&#34;write TF data ...&#34;)
        if not writeTf():
            return False
        info(&#34;done&#34;)
        return True

    wasSilent = isSilent()
    setSilent(silent)
    result = process()
    setSilent(wasSilent)
    return result</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#combine">Combine</a><ul>
<li><a href="#usage">Usage</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.compose" href="index.html">tf.compose</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.compose.combine.combine" href="#tf.compose.combine.combine">combine</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://www.dans.knaw.nl"><img alt="DANS" src="../../tf/images/DANS-logo.png" width="200" alt="DANS"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>